<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang = "en">
<head>
    <title>hello,world</title>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <script type="text/javascript" >
    /*
    range2的例子我们可以看到
    Range.prototype定义为一个新对象，包含了所需要的方法
    其实也可以完全定义在Range中
    任何JS函数都可以用作构造函数，并且调用构造函数式需要用到一个prototype属性的。
    因此每个JS函数（ES5的Function.bind方法返回的函数除外）都拥有一个prototype属性
    这个对象包含一个不可枚举属性的constructor;
    var F = function() {};
    var p = F.prototype;
    var c = p.constructor;
    c === F //true 对于任意函数F.prototype.constructor == F
    我们可以看到构造函数的原型中存在预先定义的constructor属性，这意味着对象通常继承
    constructor均指代他们的构造函数。
    由于构造函数式类的"公共表示"，因此这个constructor属性为对象提供了类
    var o = new F();
    o.constructor === F; //true
    range2的例子中使用了它自身的一个新对象重写预定义的Range.prototype对象，
    因此新定义的原型对象就不含有constructor属性。我们可以显示的给原型添加一个构造函数

     Range.prototype = {
        constructor: Range; //显示设置构造函数反向引用
        includes: function(x) { return this.from <= x && x <= this.to; },
        foreach: function(f) { for(var x = Math.ceil(this.from); x <= this.to ; x++) f(x);
        },
        toString: function (f) { return  "(" + this.from + "..." + this.to + ")"; }
    }
    获取是使用预定义的原型对象
    也就是说
    这样就不会重写，只是扩展了预定义的Range.prototype对象
    Range.prototype.includes = function(x) { return this.from <= x && x <= this.to; },
    Range.prototype.foreach  = function(f) { for(var x = Math.ceil(this.from); x <= this.to ; x++) f(x);
    },
    Range.prototype.toString = function (f) { return  "(" + this.from + "..." + this.to + ")"; }

    */

    /*


    */

    /*

    */

    /*

    */

    /*




    */



    function range2() {

    function Range(from,to) {
        this.from =from;
        this.to = to;
    }

    Range.prototype = {
        includes: function(x) { return this.from <= x && x <= this.to; },
        foreach: function(f) { for(var x = Math.ceil(this.from); x <= this.to ; x++) f(x);
        },
        toString: function (f) { return  "(" + this.from + "..." + this.to + ")"; }
    }

        var r = new Range(1,3);
        console.log(r.includes(2));
        r.foreach(console.log);
        console.log(r);
    }
    </script>
</head>
<body>

<p>Imagine a form with five fields</p>
</body>
<body onload="range2()">
</body>

</html>