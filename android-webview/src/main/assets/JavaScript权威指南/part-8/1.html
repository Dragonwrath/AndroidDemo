<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang = "en">
<head>
    <title>hello,world</title>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <script type="text/javascript">
    /*
    如果一个函数不包含return语句，那它只执行函数体中的每个语句，并返回undefined给调用者
    在ES3和费严格的ES5对函数调用的规定，调用上下文(this的值)是全局对象。
    然后在严格模式下调用上下文是undefined

    在函数体内部有个默认的arguments数组，但是它并不是真正的数组，
    它是一个实参对象，么个实参都是包含以数字为索引的一组元素以及length
    例如
    function f(x,y,z) {
        //x 就是arguments[0]
    }
    除了数组元素，实参对象还定义了callee和caller属性
    ES5严格模式中对这个属性的读写操作都会产生一个类型错误
    ES5标准规范规定callee属性只带当前正在进行的函数
    caller是非标准的，大多数浏览器都实现了这个属性，它指代当前正在执行的函数的函数
    caller属性可以访问调用栈。
    callee属性可以用来调用自身
    例如下面的递归调用
    var factorial = function(x) {
        if(x <= 1) return 1;
        return x * arguments.callee(x-1);
    }

    */

    /*
    直接调用一个匿名函数,注意相应的圆括号是必须的
    (function() { //模块代码} ());
    */

    /*
    函数对象可以通过作用域相互关联起来，函数体内部的变量都可以保存在函数作用域内。
    这种特性成为闭包
    */

    /*
    函数属性
    length属性
    function check(args) {
        var actual = args.length; //实参个数
        var expected = args.callee.length; //期望的实参个数
        if (actual != expected)
        throw Error("Error");
    }

    function f(x,y,z) {
        check(arguments);
        return x+ y + z;
    }

    prototype
    属性指向一个对象的引用，这个对象成为原型对象

    call方法和apply方法
    调用相应的指定方法
    我们以对象o调用函数f为例
    call方法调用传递的是具体个数的参数
    f.call(o,1,2);
    apply方法调用的时候传递的是数组
    f.apply(o,[1,2]);

    bind方法是在ES5中新增的方法，但是ES3可以轻易的模拟出来
    该方法的主要作用是将函数绑定到某个对象上，之后返回一个新的函数
    function f(y) { return this.x+y;}
    var o = {x : 1};
    var g = f.bind(o);
    g(2);
    ES3中
    function bind(f,o) {
        if(f.bind) return f.bind(o);
        else return function(){
            return f.apply(o,arguments);
        }
    }
    ES5中
        bind方法传入的实参也会绑定到this。
        因此 bind之后，就已经传入相应的值，并且不会再改变
        var sum = function(x,y) { return x+y;} ;
        var succ = sum.bind(null,1);
        succ(2,3); //结果为3
        succ = sum.bind(null,1,5);
         succ(2,3);//结果为6

    */

    /*


    */
    function hello() {
        var sum = function(x,y) { return x+y;} ;
        var succ = sum.bind(null,1,5);
        document.writeln(succ(2,3));
    }
	</script>
</head>
<body>

<p>Imagine a form with five fields</p>
</body>
<body onload="hello()">
</body>

</html>