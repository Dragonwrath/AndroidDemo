<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang = "en">
<head>
    <title>hello,world</title>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <script type="text/javascript">
    /*
    setInterval(func, time)
    每间隔time（单位毫秒）的事件，执行相应的function，

    setTimeout(func ,time)
    设定一个事件在指定的time之后执行，

     以上函数会返回一个值，这个值可以用来传递clearInterval用于取消后续函数的调用
     HTML5规范还允许给以上两个函数传入额外的参数，并在调用函数时把这些参数传递过去，
     但是如果需要支持IE，就不要应用此传递参数的方法

    */

    /*
    Window对象的location属性引用的是Location对象，它表示该窗口中当前显示的文档的
    URL，并定义了方法来使窗口载入新的文档
    Document对象的location属性也引用到Location对象
    window.location === document.location //总是返回true
    Document对象也有一个URL属性，是文档首次载入后保存该文档的URL的静态字符串。
    如果定位到文档中的片段标识符（如#table-of-contents）,Location对象会做相应的更新。
    而document.URL则不会改变。
    Location对象的href属性是一个字符串，包含URL的完整文本，它的toString()方法会返回href
    属性的值。
    这个对象还包含protocol，host,hostname,port,pathname和search
    如果有的话
    hash属性返回URL中的片段标识符部分
    search属性返回问号之后的URL，这部分通常是某种类型的查询字符串。

    Location对象的assign方法可以使窗口载入并显示你指定的URL中的文档。
    replace方法也类似，但是它在载入新文档之前会从浏览器历史中把当前文档删除
    因此replace方法比assign方法更好,这样可以防止“后退”按钮把浏览器带回到原始文档，而相同的脚本
    再次载入新文档。
    location = "http://www.oreilly.com"; //跳转到指定页面
    location = "page2.html"; //传递相对URL，载入下一个页面
    location = #top; //纯粹的片段标识符是相对URL的一种类型，它不会让浏览器载入新文档，只会使得它滚动到文档的某个位置
    location.search = "?page*" + pagenum; //Location对象的URL分解属性，会改变URL的位置，导致重新载入一个新的文档，
                                            如果改变的是hash属性，则在当前文档中跳转。载入到下个页面

    */

    /*
    Window对象的history属性引用的是该窗口的History对象,
    它是用来把窗口的浏览器历史用文档和文档状态列表的形式表示，History对象的length属性表示浏览器列表的元素数量
    需要注意的是，脚本不能访问已保存的URL。
    其中的back和forward方法，对应于后退和前进按钮
    还可以使用go方法，指定相应的参数跳转到相应的页面
    如果窗口包含多个子窗口 如iframe元素使用back可能会导致其中的一个子窗口往回跳转到前一个显示的文档，但主窗口保留当前
    状态不变。
    现代Web应用可以不通过载入新文档动态改变自身内容。这么做可能希望用户能用“后退”和“前进”的按钮在这些动态创建的应用
    状态之间进行跳转。HTML5已经这种技术标准化
    HTML5之前的历史管理是个复杂的难题，应用程序必须要在窗口浏览历史创建一个新的条目来管理自身的历史记录。
    可以考虑一种方式是用隐藏的<iframe>来保存信息状态，并在浏览器的历史中创建条目。借助Document对象的open和write方法，
    动态的把一个新文档写入到这个隐藏的窗体。
    不过我们通常可以采用jQuery的history插件来实现。

    */

    /*
    Window对象的navigator和screen属性
    分别对应的是Navigator对象和Screen对象
    navigator属性引用的是浏览器厂商和版本的
    Navigator对象的常用属性
    appName
    appVersion
    userAgent 浏览器在它的USER-AGENT HTTP头部中发送的字符串，通常包含
        appVersion中的所有信息，并且常常也可能包含其他细节。
    platform
    onLine 浏览器是否连接到网络
    geolocation 用来确定用户地理位置信息的接口
    javaEnabled  一个非标准方法，当Java小程序时返回true
    cookieEnable 非标准方法，如果浏览器可以保存永久cookie返回true

    Screen对象
    它提供有关窗口显示的大小和可用的颜色数量信息
    width 和 height 以像素为单位的窗口打下
    availWidth 和 availHeight 实际可用的显示大小
    colorDepth 显示的BPP（bits-per-pixel） 典型值有16、24、32

    对话框
    alert 显示一条消息并等待用户关闭
    confirm 显示一条消息，要求用户点击确定或取消，返回一个布尔值
    prompt 显示一条消息，等待用户输入字符串，并返回那个字符串

    confirm和prompt都会产生阻塞

    showModalDialog显示一个包含HTML格式的“模态对话框”
    第一个参数用来指定对话框HTML内容的URL
    第二个参数是一个任意值（数组和对象均可）这个值在对话框里的脚本可以通过window.dialogArguments属性的值访问
    第三个参数是一个非标准的列表，包含以分号隔开的name = value 对，如果提供了这个参数，可以配置对话框的尺寸或其他属性。
    dialogwidth和dialogheight来设置对话框窗口的大小，用resizalbe= yes 来允许用户改变窗口大小
    window.returnValue属性的值就是此方法返回的值
    调用window.close方法关闭对话框，并使得showModalDialog返回

    由于历史原因Window对象的onerror事件处理函数的调用通过三个字符串参数
    第一个参数是描述错误的一条信息
    第二个参数是存放错误的JS代码所在的文档的URL
    第三个参数是文档中发生错误的行数
    如果该方法返回false，则通知浏览器事件处理程序已经处理了错误，
    而在Firefox里的错误处理程序必须返回true来表示它已经处理了错误
    现在已经使用try/catch异常处理语句来处理
    */


    /*
    HTMLElement对象
    Window对象会赋予一个属性，它的名字是id属性的值，
    如果相应的id是已经存在的"history"，"location","navigator"的元素
    就不会以全局变量的形式存在，因为这些ID已经被占用
    此外不要使用x作为id
    任何有id属性的HTML元素都会变成全局变量的值
    以下HTML元素如果有name属性，也会这样表现
     a applet area embed form frame frameset iframe img object
    id元素在文档中必须是唯一的，两个元素不能有相同的id
    但是对name属性无影响，其中包括的情况有
    1、元素有多于一个相同的那么属性
    2、一个元素的那么属性与另一个元素的id属性相同
    但是有name或id的iframe元素为他们隐式创建的变量不会引用表示元素自身的Elment对象


    */


    /*
    每一个标签也都有独立的browsing context，每个context 都有独立的window对象，他们之间互不干扰
    每个标签也也不会知道其他标签也正在运行的脚本，以及相应的内容。
    但是窗口不是综合其他窗口完全没有关系，一个窗口或标签页中的搅拌可以打开新的窗口或标签也，当一个脚本
    这样做时，这样多个窗口或窗口与另一个窗口的文档之间就可以相互操作

    HTML文档经常用iframe来嵌套多个文档，由iframe创建的嵌套浏览上下文使用它自己的Window对象所表示的

    window对象的open方法可以打开一个新的浏览器窗口（或标签页）
    第一个参数是在新窗口中显示的文档的URL，如果省略会跳转到about:blank
    第二个参数是新打开的窗口的名字，如果指定的是一个已经存在的窗口的名字（并且脚本允许跳转到哪个窗口）
    会直接使用已经存在的窗口，否则打开新窗口，如果省略此参数，会使用指定的名字"_blank"打开一个新的、未命名的窗口
        只有在设置了（allow to navigate） （HTML5规范）的页面才可以通过使用窗口的名字来控制窗口中的Web应用
        宽泛地说，当且仅当窗口包含的文档来自相同的源，或者这个脚本打开的哪个窗口，（或者递归地打开了窗口中打开的窗口）
        脚本才可以只通过名字来指定存在的窗口，如果一个窗口时内嵌在另一个窗口中的窗体，那么他们的脚本就可以互相导航，这种情况下，
        可以使用保留的名字“_top”顶级祖先窗口和"_parent"直接父级窗口 来获取彼此的浏览上下文

    第三个参数是一个以逗号分隔的列表，包含大小和各种属性用以表明新窗口如何打开，如果省略，会用默认大小的带有一整组标准的
    UI组件，在标签式的浏览器中会创建一个新的标签
        如果制定了这个参数，包含指定了尺寸以及一组属性，那么就更像是新创建的窗口，而不是标签
        例如 var w = window.open("smallwin.html","smallwin","width = 400,height = 300,status = yes, resizable = yes");
        由于该参数是非标准的，因此HTML5规范主张忽略它，因为它可能开启一个屏幕显示之外的窗口

    第四个只在第二个参数命名的是一个存在的窗口时才有效，它是一个布尔值，
    声明了第一个参数指定的URL是应该替换窗口浏览历史的当前条目(true)
    还是应该在窗口浏览历史中创建一个新条目(false)，false是默认值
    该方法的返回值是创建的Window对象，其中创建窗口的opener属性应用的是打开它的脚本的Window对象
    ，在其他窗口中，opener为null
    w.opener !== null //true，对由w创建的任意窗口
    w.open().opener === w //true

    close方法可以允许自动关闭由自己的JS代码创建的窗口，如果要关闭其他窗口可以用一个对话框提示用户
    即使一个窗口关闭了，但是代表他的window对象依然存在，已关闭的窗口会有个值为true的close属性，它的document会是null

    任何窗口或窗体中的JS代码都可以将自己的窗口和窗体引用为window或self
    窗体可以用parent引用包含他的窗口或窗体的Window对象
    parent.history.back()
    如果是多个船体包含，可以使用parent.parent来引用顶级窗口，或者使用top属性，来直接找到包含的顶级窗口
    一个Window对象代表的是一个顶级窗口，那么它的top属性的引用就是窗口本身，对于那些顶级窗口的直接子窗体，
    top属性就等价于parent属性
    窗体由iframe元素创建
    假设<iframe id='f1'>
    var iframeElement = document.getElementById('f1'); //表示该iframe元素对象
    var childFrame = document.getElementById('f1').contentWindow;//窗体的window对象


    对于顶层窗口的Window对象的frameElement属性永远为null
    窗体中的Window对象的frameElement部位null
    var elt = document.getElementById('f1');
    var win = elt.contentWindow;
    win.frameElement === elt;
    window.frameElement === null;
    通常不需要使用getElementById方法和contentWindow属性来获取窗口中子窗体的一弄。
    可以通过frames属性
    获取第一个子窗体 frames[0]
    第二个子窗体的第三个子窗体 frames[1].frames[2]
    窗体中使用parent.frames[1]引用兄弟窗体
    注意：frames数组里的元素是Window对象而不是iframe元素
    如果指定了iframe元素的name或id，那么除了用数字进行索引，还可以用名字来索引
    例如名字为f1的iframe 可以用frame['f1']或者frames.f1

    */

    /*
    交互窗口中的JS
    前提是同源策略没有阻止他们

    假设有两个iframe元素，分别叫做A和B，
    一个定义变量i是全局变量的一个属性，也是Window对象的一个 属性
    窗体中可以用window.i来一弄
    那么窗体B就可以引用窗体A的Window对象，parent.A.i
    窗体B中声明了一个非嵌套的函数f，可以通过B.f()来使用
    如果窗体A中频繁调用该函数，var f = parent.B.f;
    如果是两个窗体都要使用某个类
    那么可以在顶级窗口中的脚本定义新的Set对象
    var s = new Set();
    之后每个窗体显式调用父级窗口的属性来引用Set()构造函数
    new parent.Set()
    或者直接定义自己的变量来引用
    var Set = parent.Set(); var s = new Set();
    */

    function hello() {
        var msg = 'hello world';
        document.open()
		document.write(msg);
		document.close();
    }
	</script>
</head>
<body>

<p>Imagine a form with five fields</p>
</body>
<body onload="hello()">
</body>

</html>