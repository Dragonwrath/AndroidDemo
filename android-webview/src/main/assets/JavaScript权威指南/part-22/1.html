<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang = "en">
<head>
    <title>hello,world</title>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <script type="text/javascript">
    //HTML 5 API
    /*
    1-地理位置
        允许JavaScript程序向浏览器询问用户真实的地理位置。
        navigator.geoloaction.getCurrentPosition();
        navigator.geoloaction.watchPosition(); 获取当前位置，同时监控当前位置，发生变化会调用回调函数
        navigator.geoloaction.clearWatch(); 停止监视用户位置
        相应的精度值（米为单位）
        //设置地理位置特性
        function whereami(elt) {
            var options = {
                enableHighAccuracy : false, //获取高精度的位置，默认值false
                maximumAge:300000, //默认0，设置更新事件
                timeout：15000 //默认值无限长时间，愿意等待多久获取位置信息
            }
            if(navigator.geolocation)
                navigator.geolocation.getCurrentPosition(success,error,options);
            else elt.innerHTML = "Geolocation not supported";

            function error(e) {
               elt.innerHTML = "Geolocation error code:" + e.code + " error message: " + e.message;
            }

            function success(pos){
                var lat = pos.coords.latitude;
                var long = pos.coords.longtitude;
                if( pos.coords.altitude) {//海拔
                     pos.coords.altitude;
                     pos.coords.altitudeAccuracy;
                }
                if( pos.coords.speed) {
                     pos.coords.speed；
                     pos.coords.heading;
                }
            }
        }
    */

    /*
    2-历史记录管理
    简单的历史管理利用location.hash和hashchange事件。
    hash属性设置URL的片段标识符，通常用来指定要滚动到文档中的某一部分的ID。
    location.hash 可以设置为一个元素的ID,也可以设置为任何字符串
    如果设置了location.hash属性，通过 后退 和 前进 按钮来切换不同的文档状态，支持HTML5的浏览器
    一旦发现片段标识符发生改变，就会在Window对象上触发一个hashchange事件，在迟滞hashchange事件的
    浏览器中，可以通过设置window.onhashchange作为一个程序的处理函数。
    HTML5 还定义了一个更加复杂和强健的历史记录管理方法，该方法包含history.pushState()
    和popstate事件。
    当一个Web应用进入一个新的状态是，他会调用history.pushState()方法将该状态添加到浏览器的浏览器历史记录中
    该方法的第一个参数是一个对象，该对象包含用于恢复当前文档状态所需的所有信息。
        该对象时可以任何通过JSON.stringify()方法转换成相应字符串形式的对象，也可以是其它类似Date和RegExp
        这样的特定的本地类型
    第二个可选参数是一个可选的标题，浏览器可以使用它来标识浏览历史记录中保存的状态
    第三个参数是一个可选的URL，标识当前状态的位置。
    History对象还定义了一个replaceState()方法，该方法和pushState()方法接受同样的参数。
    它将用新的状态替换当前的历史状态。
    浏览器通过后退和前进按钮是，浏览器会在Window对象上触发一个popstate事件。与该事件相关联的事件对象有一个state属性
    该属性包含传递给pushState()方法的状态对象的副本
    Firefox 4 对历史记录API做了两点修改
    1、Firefox 4 是的Histroy对象自身可以通过state属性获取当前状态，这意味着新载入的页面无需等待popstate事件
    2、对于没有任何保存状态的新载入的页面，Firefox 4不再触发popstate事件




    */

    /*
    3-跨域消息传递
    一些浏览器窗口和标签之间都是相互独立的，。
    但是在某些常见中，当脚本显式打开一个新窗口或者在嵌套的窗体中运行时，多个窗口或者窗体之间
    是可以相互识别的。
    window方法，允许来自非同源脚本调用的：postMessage()方法，该方法允许有限的通信-通过异步
    消息传递的方式-来自不同源的脚本之间。
    此项技术成为 跨文档消息传递，该API定义在Window对象上的，而不是文档对象上。
    postMessage()方法接受两个参数
    第一个参数是要传递的消息，该参数可以是任意基本类型值或可以复制的对象。部分浏览器支持字符串，因此
        要想要作为消息传递对象或者数组，首先应当使用JSON.stringify()方法
    第二个参数是一个字符串，指定目标窗口的源，包括协议、主机名以及URL（可选）端口部分。
    该方法只会讲消息传递给指定的窗口如果愿意传递给任何窗口，可以直接将参数设置为"*"通配符即可。
    如果要指定和当前窗口同源的话，直接使用"/"
    在目标窗口的Window对象就会触发一个message事件，在目标窗口中的脚本可以定义通知message事件的处理函数。
    调用该事件事，会传递给他一个拥有如下属性的事件对象
    data 作为第一个参数传递给postMessage()方法的消息内容副本
    source 消息源自的Window对象
    origin 一个字符串，指定消息来源（URL 形式）
    onmessage() 事件处理程序首先检查其中的origin事件，忽略来自未知源的消息

    */
    /*
    4-Web Worker
    该标准定义了客户端JS无法多线程的问题，其中定义的Worker是指执行代码的并行线程。
    其中定义的"Worker"是指指定代码的并行线程。
    Web Workers处在一个自包含的
    */
    function hello() {
        var msg = 'hello world';
        document.open()
		document.write(msg);
		document.close();
    }
	</script>
</head>
<body>

<p>Imagine a form with five fields</p>
</body>
<body onload="hello()">
</body>

</html>